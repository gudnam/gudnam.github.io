---
layout: post
categories: Study
tags: [Kotlin, MVP, DI]
author: Gudnam
title: 코틀린에서 MVP 패턴을 DI로 구현해보기!
---
<div class="message"> 
MVC, MVVM, MVP 등의 View logic 패턴중에 MVP 를 선택한 이유는 View & Logic 분리가 쉽기도 하지만 테스트 코드를 깔끔하게 작성할 수 있기 때문이다. DI 를 사용하는 이유도 이와 비슷하다
</div> 

# 개념 간단히 살펴보기

## MVP ?
![mvp](/public/img/mvp_architecture.png)

	VIEW
		오직 화면 구성에 관련된 기능만 있다
		이곳에서 로직은 왠만하면 피하라!
		모든 이벤트는 Presenter 에게 전가하기

	PRESENTER	
		원하는 화면을 결정해 View 에게 전달한다 (View 와 1:1 관계)
		View 를 보여주기 위한 Logic 은 이곳에서!
		화면을 테스트하고 싶다면 이곳에 테스트 코드를 작성하라!

	MODEL
		화면에 보여지는 정보가 있는 곳
		복잡한 Business Logic 담당
		예를 들어 DB, 서버 연동 등등에서 데이터 가져올 때 사용
		
## DI ?

> Dependency Inject

[쉽게 설명해 놓은 슬라이드 쉐어](https://www.slideshare.net/baejjae93/dependency-injection-36867592)

	좋은 프로그램은 객체간의 결합성(Coupling), 의존성(Dependency)가 낮을수록 좋다고 한다
	Coupling, Dependency를 낮추기 위해 탄생한 개념이 DI 패턴이다

* A, B 두 객체가 있다
* A가 B를 연결하기 위해서는 객체를 생성, 초기화 하는 작업이 필요하다
{% highlight js %}
// ex) Java
B b = new B("init");
{% endhighlight %}
* 하지만 A 객체에서 B를 생성했다는 것은 A는 B에 종속되고 있다는 뜻이다
* 종속 됐다는 말은 만약 B가 변경되면 A도 어쩔 수 없이 변경된다는 것이다
* 방법은 A가 B를 생성하지 말고, 외부의 무언가가  B를 생성하고 그걸 A한테 주면(Inject) 된다
* A와 B는 이제 한결 멀어졌다


# 이제 개발을 시작해보자!

## 개발을 위한 환경설정
> Kotlin plugin, Dagger2 framework

### Kotlin
1. Install kotlin plugin
![install_kotlin](/public/img/install_kotlin.png)

2. 빌드 스크립트
{% highlight js %}
// build.gradle
buildscript {
  ext.kotlin_version = '1.0.4'
  repositories {
    jcenter() 
  }
  dependencies {
    ...
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
  }
}
{% endhighlight %}

{% highlight js %}
// app/build.gradle
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'

android {
  ...
}

dependencies {
  compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
  ...
}
{% endhighlight %}

### Dagger2
> DI Framework

{% highlight js %}
// app/build.gradle
...

dependencies {
  kapt "com.google.dagger:dagger-compiler:$daggerVersion"
  compile "com.google.dagger:dagger:$daggerVersion"
  ...
}
{% endhighlight %}

## MVP & DI 개발

### MVP 

* View
{% highlight js %}
// Create View
interface PresentationView

...

// Create MainView
class MainView : PresentationView {
  ...
}
{% endhighlight %}

* Presenter
{% highlight js %}
// Create Presentere
interface Presenter<out T> {
  val view: T
}

...

// Create MainPresenter
class MainPresenter(override val view: MainView) : Presenter<MainView> {
  ...
}
{% endhighlight %}
